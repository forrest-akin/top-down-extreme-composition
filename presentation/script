BEGIN PRESENTATION

Hello, JS.LA!
->
I want to show you some code, and tell you a few things I like about it.
-> 
This is a function, an application of the Duration domain
I'm using the Unary interface to communicate it's a function that takes a string and returns a DurationString
Instead of dealing with arguments and variables, I'm using the pipe function to compose 3 other functions to satisfy my requirements
Let's take a peek into the Duration domain
->
It's the same thing here;
no function bodies!
I love exercising the constraint of not creating function bodies because without them, I'm way less likely to keep adding lines to a function;
everything is way less hackable!
Instead I'm encouraged to consider what composition of existing functions will accomplish the task at hand;
and that's exactly what we find here!
every function is defined completely in terms of other simpler functions without adding any ad-hoc handling of data;
it's compositional!
I love this because I'm always communicating at a high level WHAT will be done and never concerning myself with the details of HOW it will be done;
it's declarative!
->
but I didn't always write code like this.
When I started I might have approached it like this
->
one big function with the entire implementation
and more recently I might've done something like this
->
similarly factored, but lacking the structure and compositionality of the original example
->
but this isn't my progression from writing bad code to good;
code isn't simply good or bad.
as software engineers, we constantly juggle a myriad of concerns when writing code and it's our values that inform which ones we choose to prioritize
and that's what this code represents to me
->
an accumulation of values over the years, many of which were a result of some of the worst experiences in my career
and tonight I'd like to share one of those experiences with you
I would've called this is a coding horror, but that name was already taken
->
so instead, this is my Code Crucible
->
I hope it'll offer some insight into how you can use challenging circumstances as fuel for discovering and refining your own values
->
The project: Date-Based Pricing
I was still pretty new to the company, but I guess I had made a good impression because they decided to throw me head first into the deep end
this was a solo, system-spanning, full-stack project where I would be
creating a new service responsible for all pricing logic
and implement date-based pricing, giving users the ability to assign start and/or end dates for prices on products and pricesheets
little did I know, there were problems
->
problems I was mostly clueless about, but slowly and painfully discovered as the project progressed
naturally, the requirements were extremely vague, offering little to nothing in terms of acceptance criteria
the pricing logic I was meant to consolidate into my new service was scattered across the entire system
ad-hoc pricing logic was all over the place on the front-end and the back-end
which made sense because this was a 5+ year old NodeJS system in which quality maintenance had rarely been prioritized
and when you combine all of that with the fact that I was new to the company and had little domain knowledge or familiarity with the codebase
this was the perfect storm - I was definitely set up to fail on this project.
here's a peek into some of the
->
challenges I experienced
->
Testing
- I didn't always write tests...
and that definitely bit me in this project
it made me a lot slower due to all the mental processing I was constantly doing,
and it resulted in a lot of regressions in the early stages
but luckily I finally caved and started writing tests;
I probably couldn't have finished the project without them
->
ah yes, the tech debt
this term gets thrown around pretty loosely, but it absolutely applies in this case
this was the definition of legacy code - poorly tested code I didn't write
many functions had grown beyond 500 lines with side-effects around every corner
to top it off there was a nice helping of in-house framework magic
I think it would be a miracle if any human was able to reason about this system
finally
->
this was a long solo project
it took at least twice as long as planned to complete - probably closer to three times
because I was constantly discovering more landmines
I ended up pulling several all-nighters because I just wanted it to be over
this of course didn't help my mental well being
it was an extremely lonely experience
I was working near people but not with them - I desperately wanted some form of collaboration
I grew resentful for having such an awful project dumped on me
it seemed like a hopeless situation
->
so I went searching for answers
->
how does code become like this??
who do I blame?
well it turns out no one wrote this code in malice; anger, perhaps, but not malice
I started learning about the role values played in software from people like Brian Cantrell and Steve Klabnik and it all started to add up
what I was experiencing was Conway's Law - the idea that a software system's structure mirrors the organization that built it
there were deep-rooted issues in the organization that contributed to development being carried out in a haphazard frenzy
it was no wonder that after over 5 years this is what the system had become
->
Understanding this helped me be less resentful
->
but there was no way I was going to change this organization
so what could I do to prevent code from becoming like this?
I had been dabbling with some functional ideas for a couple years, but this really sent me down the rabbit hole
FP is all about applying techniques to maintain reasonability in software as it evolves - something I was desperately missing
so I spent tons of my free time finding resources to learn more and took every opportunity to apply what I was learning to the project.
I read Brian Lonsdorf's Mostly Adequate Guide to Functional Programming and Eric Elliot's Composing Software
I found new podcasts like Magic Readalong and Corecursive
I found new heroes:
Brian Lonsdorf for FP-in-JS,
Runar Bjarnson for showing me how constraints liberate,
and Bartosz Milewski for showing me how category theory is a powerful abstraction for composing software
->
focusing my energy on learning truly helped me keep my sanity
->
but I was still all alone, so I went looking for community in whatever way I could
I created a recurring Tech Talks meeting at work to provide a platform for people to share whatever was interesting to them
I got more involved with js.la, signing up as a mentor for the mentorship program as well as signing up to be a presenter
I joined the functional-programming Slack team
I started attending the santa monica haskell meetup
and was lucky enough to have a couple of friends willing to nerd out with me on functional topics
eventually I realized I would be much happier at a company that shared the values I was discovering in myself
so I searched for companies that explicitly valued quality and functional programming
I only found two and before I knew it I was signing an offer with my current employer, CJ Affiliate
in a lot of ways it's the company I've been trying to find since 2016;
I'm surrounded by people that care about quality that I have a ton to learn from.
I don't think I would have ended up at CJ if this experience hadn't forced me to dig deeper into what I valued
I haven't arrived; I still have a long road ahead of me in this career
->
but I've found more of who I am and who I want to be.
->
so that's the end of this story
in closing, I just want to say the obvious - work isn't always what we hope
sometimes it's the worst and tries us in ways we never expected, but we can use these experiences as fuel for our own self-discovery and growth
but don't go it alone; find a community that shares your values and will support you in digging into your passions
thank you so much JS.LA - good night!
->
END PRESENTATION
