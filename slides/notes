JS.LA PRESENTATION CONSIDERATIONS

What did you want
/ why did you want it
/ what led to the creation of what you are demoing?

What did you do to get what you wanted
/ what did you do to create your thing
/ what went wrong
/ what went right?

What did you learn
/ what happened that you didn't expect
/ what would you change if you had to do it over again
/ what would you tell someone attempting the same thing?

Your talk should take no longer than 20 minutes; do practice and time yourself!



BRAIN STORMING

what is the purpose of high-level programming languages?
    the purpose of high-level programming languages is to help programmers encode programs in a way that clearly communicates intent to the humans that will be reading them by abstracting away low-level implementation details for compilers to handle for us

what is intent?
    intent is purpose. in programming terms, it's the intended result of evaluating an expression

what is abstraction?
    "The essence of abstractions is preserving information that is relevant in a given context, and forgetting information that is irrelevant in that context." - John Vogel Guttag

    abstraction helps us do more with less. consider spoken language: a ton of meaning can be packed into a single word without skipping a beat. a good abstraction is exactly like that! it allows you to express your intent in terms of the domain you're working in without dilluting it with implementation details. but an abstraction needs to be precisely defined, with a consistent meaning to be useful. in human languages, dictionaries precisely define every word in terms of other words - a beautiful example of recursive definition in the wild. yet even with dictionaries, we can run into trouble. sometimes the meaning of a word completely changes depending on the context it's used. words can be pronounced the same, but have different spelling depending on the meaning - and vice versa! this is all very confusing! abstractions that behave different depending on context can be just as confusing. the easiest abstractions to work with and most reliable to build others upon always exhibit the same behavior regardless of context. if we try to build abstractions on top of others where context matters, we might leak some irrelevant details unexpectedly.

what is an example of a good abstraction?
    pure functions! a pure function acts like a mapping of its inputs to an output. all possible inputs will always map to the same output. you never have to lift your scope of thought outside of the function to reason about what it does. but we're not completely home free. anything goes inside of a function as long as it always maps inputs to outputs. an entire application could be written inside of a pure function. what happens in the function matters if we want to consistently be expressing the intent of a function at a contextually appropriate level of abstraction. things like variables seem innocent, but each one ends up being a liability that you have to push to your mental stack in order to understand the function's intent.

what can be done?
    composition! and not just any composition - function composition. function composition allows us to create new abstractions exclusively in terms of existing abstractions without introducing any ad-hoc glue code. if you think about it, all software is a composition of abstractions. if we embrace this concept, we start to think about how software is built much differently. by focusing on composability, we get way more mileage out of the code we build because it can be used in contexts we didn't even consider when we wrote the code - because context doesn't matter to pure functions! this is a huge productivity boost! when we insist on expressing new abstractions on existing abstractions, we simultaneously stop reinventing the wheel. when we focus on just satisfying our immediate use case, we end up constantly reinventing countless tiny wheels, which greatly hinders our productivity. so how do we begin building things in this manner? from the top, of course!

welcome to top-down design: extreme composition edition

Sum Time Strings
Input: "12:32 34:01 15:23 9:27 55:22 25:56"
Output: "2:32:41"
